Kubernetes glossary.

Fundamental

Affinity
In Kubernetes, affinity is a set of rules that give hints to the scheduler about where to place pods.
There are two kinds of affinity:

node affinity
pod-to-pod affinity
The rules are defined using the Kubernetes labels, and selectors specified in pods, and they can be either required or preferred, depending on how strictly you want the scheduler to enforce them.

Annotation
A key-value pair that is used to attach arbitrary non-identifying metadata to objects.
The metadata in an annotation can be small or large, structured or unstructured, and can include characters not permitted by labels. Clients such as tools and libraries can retrieve this metadata.

API Group
A set of related paths in Kubernetes API.
You can enable or disable each API group by changing the configuration of your API server. You can also disable or enable paths to specific resources. An API group makes it easier to extend the Kubernetes API. The API group is specified in a REST path and in the apiVersion field of a serialized object.

Read API Group for more information.
API server
Also known as: kube-apiserver
The API server is a component of the Kubernetes control plane that exposes the Kubernetes API. The API server is the front end for the Kubernetes control plane.
The main implementation of a Kubernetes API server is kube-apiserver. kube-apiserver is designed to scale horizontally—that is, it scales by deploying more instances. You can run several instances of kube-apiserver and balance traffic between those instances.

Applications
The layer where various containerized applications run.

cgroup (control group)
A group of Linux processes with optional resource isolation, accounting and limits.
cgroup is a Linux kernel feature that limits, accounts for, and isolates the resource usage (CPU, memory, disk I/O, network) for a collection of processes.

Cluster
A set of worker machines, called nodes, that run containerized applications. Every cluster has at least one worker node.
The worker node(s) host the Pods that are the components of the application workload. The control plane manages the worker nodes and the Pods in the cluster. In production environments, the control plane usually runs across multiple computers and a cluster usually runs multiple nodes, providing fault-tolerance and high availability.

Common Expression Language
Also known as: CEL
A general-purpose expression language that's designed to be fast, portable, and safe to execute.
In Kubernetes, CEL can be used to run queries and perform fine-grained filtering. For example, you can use CEL expressions with dynamic admission control to filter for specific fields in requests, and with dynamic resource allocation (DRA) to select resources based on specific attributes.

Container
A lightweight and portable executable image that contains software and all of its dependencies.
Containers decouple applications from underlying host infrastructure to make deployment easier in different cloud or OS environments, and for easier scaling. The applications that run inside containers are called containerized applications. The process of bundling these applications and their dependencies into a container image is called containerization.

Container Environment Variables
Container environment variables are name=value pairs that provide useful information into containers running in a pod
Container environment variables provide information that is required by the running containerized applications along with information about important related details to the containers. For example, file system details, information about the container itself, and other cluster resources such as service endpoints.

Container Runtime
A fundamental component that empowers Kubernetes to run containers effectively. It is responsible for managing the execution and lifecycle of containers within the Kubernetes environment.
Kubernetes supports container runtimes such as containerd, CRI-O, and any other implementation of the Kubernetes CRI (Container Runtime Interface).

Container Runtime Interface (CRI)
The main protocol for the communication between the kubelet and Container Runtime.
The Kubernetes Container Runtime Interface (CRI) defines the main gRPC protocol for the communication between the node components kubelet and container runtime.

Control Plane
The container orchestration layer that exposes the API and interfaces to define, deploy, and manage the lifecycle of containers.
This layer is composed by many different components, such as (but not restricted to):

- etcd
- API Server
- Scheduler
- Controller Manager
- Cloud Controller Manager
These components can be run as traditional operating system services (daemons) or as containers. The hosts running these components were historically called masters.

Controller
In Kubernetes, controllers are control loops that watch the state of your cluster, then make or request changes where needed. Each controller tries to move the current cluster state closer to the desired state.
Controllers watch the shared state of your cluster through the apiserver (part of the Control Plane).

Some controllers also run inside the control plane, providing control loops that are core to Kubernetes' operations. For example: the deployment controller, the daemonset controller, the namespace controller, and the persistent volume controller (and others) all run within the kube-controller-manager.

CustomResourceDefinition
A kind of API object that defines a new custom API to add to your Kubernetes API server, without building a complete custom server.
CustomResourceDefinitions let you extend the Kubernetes API for your environment if the built-in API resources can't meet your needs.

DaemonSet
Ensures a copy of a Pod is running across a set of nodes in a cluster.
Used to deploy system daemons such as log collectors and monitoring agents that typically must run on every Node.

Data Plane
The layer that provides capacity such as CPU, memory, network, and storage so that the containers can run and connect to a network.

Deployment
An API object that manages a replicated application, typically by running Pods with no local state.
Each replica is represented by a Pod, and the Pods are distributed among the nodes of a cluster. For workloads that do require local state, consider using a StatefulSet.

Device
One or more infrastructure resources that are directly or indirectly attached to your nodes.
Devices might be commercial products like GPUs, or custom hardware like ASIC boards. Attached devices usually require device drivers that let Kubernetes Pods access the devices.

Device Plugin
Device plugins run on worker Nodes and provide Pods with access to infrastructure resources, such as local hardware, that require vendor-specific initialization or setup steps.
Device plugins advertise resources to the kubelet, so that workload Pods can access hardware features that relate to the Node where that Pod is running. You can deploy a device plugin as a DaemonSet, or install the device plugin software directly on each target Node.

See Device Plugins for more information.

Disruption
Disruptions are events that lead to one or more Pods going out of service. A disruption has consequences for workload management resources, such as Deployment, that rely on the affected Pods.
If you, as cluster operator, destroy a Pod that belongs to an application, Kubernetes terms that a voluntary disruption. If a Pod goes offline because of a Node failure, or an outage affecting a wider failure zone, Kubernetes terms that an involuntary disruption.

See Disruptions for more information.

Docker
Docker (specifically, Docker Engine) is a software technology providing operating-system-level virtualization also known as containers.
Docker uses the resource isolation features of the Linux kernel such as cgroups and kernel namespaces, and a union-capable file system such as OverlayFS and others to allow independent containers to run within a single Linux instance, avoiding the overhead of starting and maintaining virtual machines (VMs).

Dockershim
The dockershim is a component of Kubernetes version 1.23 and earlier. It allows the kubelet to communicate with Docker Engine.
Starting with version 1.24, dockershim has been removed from Kubernetes.

Drain
The process of safely evicting Pods from a Node to prepare it for maintenance or removal from a cluster.
The kubectl drain command is used to mark a Node as going out of service. When executed, it evicts all Pods from the Node. If an eviction request is temporarily rejected, kubectl drain retries until all Pods are terminated or a configurable timeout is reached.

Duration
A string value representing an amount of time.
The format of a (Kubernetes) duration is based on the time.Duration type from the Go programming language.

In Kubernetes APIs that use durations, the value is expressed as series of a non-negative integers combined with a time unit suffix. You can have more than one time quantity and the duration is the sum of those time quantities. The valid time units are "ns", "µs" (or "us"), "ms", "s", "m", and "h".

For example: 5s represents a duration of five seconds, and 1m30s represents a duration of one minute and thirty seconds.

Ephemeral Container
A Container type that you can temporarily run inside a Pod.
If you want to investigate a Pod that's running with problems, you can add an ephemeral container to that Pod and carry out diagnostics. Ephemeral containers have no resource or scheduling guarantees, and you should not use them to run any part of the workload itself.

Ephemeral containers are not supported by static pods.

Event
A Kubernetes object that describes state changes or notable occurrences in the cluster.
Events have a limited retention time and triggers and messages may evolve with time. Event consumers should not rely on the timing of an event with a given reason reflecting a consistent underlying trigger, or the continued existence of events with that reason.

Events should be treated as informative, best-effort, supplemental data.

In Kubernetes, auditing generates a different kind of Event record (API group audit.k8s.io).

Extensions
Extensions are software components that extend and deeply integrate with Kubernetes to support new types of hardware.
Many cluster administrators use a hosted or distribution instance of Kubernetes. These clusters come with extensions pre-installed. As a result, most Kubernetes users will not need to install extensions and even fewer users will need to author new ones.

Feature gate
Feature gates are a set of keys (opaque string values) that you can use to control which Kubernetes features are enabled in your cluster.
You can turn these features on or off using the --feature-gates command line flag on each Kubernetes component. Each Kubernetes component lets you enable or disable a set of feature gates that are relevant to that component. The Kubernetes documentation lists all current feature gates and what they control.

Finalizer
Finalizers are namespaced keys that tell Kubernetes to wait until specific conditions are met before it fully deletes resources that are marked for deletion. Finalizers alert controllers to clean up resources the deleted object owned.
When you tell Kubernetes to delete an object that has finalizers specified for it, the Kubernetes API marks the object for deletion by populating .metadata.deletionTimestamp, and returns a 202 status code (HTTP "Accepted"). The target object remains in a terminating state while the control plane, or other components, take the actions defined by the finalizers. After these actions are complete, the controller removes the relevant finalizers from the target object. When the metadata.finalizers field is empty, Kubernetes considers the deletion complete and deletes the object.

You can use finalizers to control garbage collection of resources. For example, you can define a finalizer to clean up related API resources or infrastructure before the controller deletes the object being finalized.

Garbage Collection
Garbage collection is a collective term for the various mechanisms Kubernetes uses to clean up cluster resources.
Kubernetes uses garbage collection to clean up resources like unused containers and images, failed Pods, objects owned by the targeted resource, completed Jobs, and resources that have expired or failed.

Image
Stored instance of a Container that holds a set of software needed to run an application.
A way of packaging software that allows it to be stored in a container registry, pulled to a local system, and run as an application. Meta data is included in the image that can indicate what executable to run, who built it, and other information.

Init Container
One or more initialization containers that must run to completion before any app containers run.
Initialization (init) containers are like regular app containers, with one difference: init containers must run to completion before any app containers can start. Init containers run in series: each init container must run to completion before the next init container begins.

Unlike sidecar containers, init containers do not remain running after Pod startup.

For more information, read init containers.

Job
A finite or batch task that runs to completion.
Creates one or more Pod objects and ensures that a specified number of them successfully terminate. As Pods successfully complete, the Job tracks the successful completions.

kube-controller-manager
Control plane component that runs controller processes.
Logically, each controller is a separate process, but to reduce complexity, they are all compiled into a single binary and run in a single process.

kube-proxy
kube-proxy is a network proxy that runs on each node in your cluster, implementing part of the Kubernetes Service concept.
kube-proxy maintains network rules on nodes. These network rules allow network communication to your Pods from network sessions inside or outside of your cluster.

kube-proxy uses the operating system packet filtering layer if there is one and it's available. Otherwise, kube-proxy forwards the traffic itself.

Kubectl
Also known as: kubectl
Command line tool for communicating with a Kubernetes cluster's control plane, using the Kubernetes API.
You can use kubectl to create, inspect, update, and delete Kubernetes objects.

Kubelet
An agent that runs on each node in the cluster. It makes sure that containers are running in a Pod.
The kubelet takes a set of PodSpecs that are provided through various mechanisms and ensures that the containers described in those PodSpecs are running and healthy. The kubelet doesn't manage containers which were not created by Kubernetes.

Kubernetes API
The application that serves Kubernetes functionality through a RESTful interface and stores the state of the cluster.
Kubernetes resources and "records of intent" are all stored as API objects, and modified via RESTful calls to the API. The API allows configuration to be managed in a declarative way. Users can interact with the Kubernetes API directly, or via tools like kubectl. The core Kubernetes API is flexible and can also be extended to support custom resources.

Label
Tags objects with identifying attributes that are meaningful and relevant to users.
Labels are key/value pairs that are attached to objects such as Pods. They are used to organize and to select subsets of objects.

LimitRange
Constraints resource consumption per container or Pod, specified for a particular namespace.
A LimitRange either limits the quantity of API resources that can be created (for a particular resource type), or the amount of infrastructure resources that may be requested/consumed by individual containers or Pods within a namespace.

Logging
Logs are the list of events that are logged by cluster or application.

Manifest
Specification of a Kubernetes API object in JSON or YAML format.
A manifest specifies the desired state of an object that Kubernetes will maintain when you apply the manifest. For YAML format, each file can contain multiple manifests.

Master
Legacy term, used as synonym for nodes hosting the control plane.

Minikube
A tool for running Kubernetes locally.

Mirror Pod
A pod object that a kubelet uses to represent a static pod
When the kubelet finds a static pod in its configuration, it automatically tries to create a Pod object on the Kubernetes API server for it. This means that the pod will be visible on the API server, but cannot be controlled from there.

(For example, removing a mirror pod will not stop the kubelet daemon from running it).

Name
A client-provided string that refers to an object in a resource URL, such as /api/v1/pods/some-name.
Only one object of a given kind can have a given name at a time. However, if you delete the object, you can make a new object with the same name.

Namespace
An abstraction used by Kubernetes to support isolation of groups of API resources within a single cluster.
Namespaces are used to organize objects in a cluster and provide a way to divide cluster resources. Names of resources need to be unique within a namespace, but not across namespaces. Namespace-based scoping is applicable only for namespaced resources (for example: Pods, Deployments, Services) and not for cluster-wide resources (for example: StorageClasses, Nodes, PersistentVolumes).

Node
A node is a worker machine in Kubernetes.
A worker node may be a VM or physical machine, depending on the cluster. It has local daemons or services necessary to run Pods and is managed by the control plane. The daemons on a node include kubelet, kube-proxy, and a container runtime implementing the CRI such as Docker.

In early Kubernetes versions, Nodes were called "Minions".

Object
An entity in the Kubernetes system. An object is an API resource that the Kubernetes API uses to represent the state of your cluster.
A Kubernetes object is typically a “record of intent”—once you create the object, the Kubernetes control plane works constantly to ensure that the item it represents actually exists. By creating an object, you're effectively telling the Kubernetes system what you want that part of your cluster's workload to look like; this is your cluster's desired state.

Pod
The smallest and simplest Kubernetes object. A Pod represents a set of running containers on your cluster.
A Pod is typically set up to run a single primary container. It can also run optional sidecar containers that add supplementary features like logging. Pods are commonly managed by a Deployment.

Pod Lifecycle
The sequence of states through which a Pod passes during its lifetime.
The Pod Lifecycle is defined by the states or phases of a Pod. There are five possible Pod phases: Pending, Running, Succeeded, Failed, and Unknown. A high-level description of the Pod state is summarized in the PodStatus phase field.

QoS Class
QoS Class (Quality of Service Class) provides a way for Kubernetes to classify Pods within the cluster into several classes and make decisions about scheduling and eviction.
QoS Class of a Pod is set at creation time based on its infrastructure resource requests and limits settings. QoS classes are used to make decisions about Pods scheduling and eviction. Kubernetes can assign one of the following QoS classes to a Pod: Guaranteed, Burstable or BestEffort.

Quantity
A whole-number representation of small or large numbers using SI suffixes.

RBAC (Role-Based Access Control)
Manages authorization decisions, allowing admins to dynamically configure access policies through the Kubernetes API.
RBAC utilizes four kinds of Kubernetes objects:

- Role
    Defines permission rules in a specific namespace.

- ClusterRole
    Defines permission rules cluster-wide.

- RoleBinding
    Grants the permissions defined in a role to a set of users in a specific namespace.

- ClusterRoleBinding
    Grants the permissions defined in a role to a set of users cluster-wide.

Replica
A copy or duplicate of a Pod or a set of pods. Replicas ensure high availability, scalability, and fault tolerance by maintaining multiple identical instances of a pod.
Replicas are commonly used in Kubernetes to achieve the desired application state and reliability. They enable workload scaling and distribution across multiple nodes in a cluster.

By defining the number of replicas in a Deployment or ReplicaSet, Kubernetes ensures that the specified number of instances are running, automatically adjusting the count as needed.

Replica management allows for efficient load balancing, rolling updates, and self-healing capabilities in a Kubernetes cluster.

ReplicaSet
A ReplicaSet (aims to) maintain a set of replica Pods running at any given time.
Workload objects such as Deployment make use of ReplicaSets to ensure that the configured number of Pods are running in your cluster, based on the spec of that ReplicaSet.

ResourceQuota
Object that constrains aggregate resource consumption, per Namespace.
A ResourceQuota can either limits the quantity of API resources that can be created in a namespace by type, or it can set a limit on the total amount of infrastructure resources that may be consumed on behalf of the namespace (and the objects within it).

Selector
Allows users to filter a list of API resources based on labels.
Selectors are applied when querying lists of resources to filter them by labels.

Service
A method for exposing a network application that is running as one or more Pods in your cluster.
The set of Pods targeted by a Service is (usually) determined by a selector. If more Pods are added or removed, the set of Pods matching the selector will change. The Service makes sure that network traffic can be directed to the current set of Pods for the workload.

Kubernetes Services either use IP networking (IPv4, IPv6, or both), or reference an external name in the Domain Name System (DNS).

The Service abstraction enables other mechanisms, such as Ingress and Gateway.

ServiceAccount
Provides an identity for processes that run in a Pod.
When processes inside Pods access the cluster, they are authenticated by the API server as a particular service account, for example, default. When you create a Pod, if you do not specify a service account, it is automatically assigned the default service account in the same Namespace.

Shuffle-sharding
A technique for assigning requests to queues that provides better isolation than hashing modulo the number of queues.

Sidecar Container
One or more containers that are typically started before any app containers run.
Sidecar containers are like regular app containers, but with a different purpose: the sidecar provides a Pod-local service to the main app container. Unlike init containers, sidecar containers continue running after Pod startup.

Read Sidecar containers for more information.

Spec
Defines how each object, like Pods or Services, should be configured and its desired state.
Almost every Kubernetes object includes two nested object fields that govern the object's configuration: the object spec and the object status. For objects that have a spec, you have to set this when you create the object, providing a description of the characteristics you want the resource to have: its desired state.

It varies for different objects like Pods, StatefulSets, and Services, detailing settings such as containers, volumes, replicas, ports, and other specifications unique to each object type. This field encapsulates what state Kubernetes should maintain for the defined object.

StatefulSet
Manages the deployment and scaling of a set of Pods, and provides guarantees about the ordering and uniqueness of these Pods.
Like a Deployment, a StatefulSet manages Pods that are based on an identical container spec. Unlike a Deployment, a StatefulSet maintains a sticky identity for each of its Pods. These pods are created from the same spec, but are not interchangeable: each has a persistent identifier that it maintains across any rescheduling.

If you want to use storage volumes to provide persistence for your workload, you can use a StatefulSet as part of the solution. Although individual Pods in a StatefulSet are susceptible to failure, the persistent Pod identifiers make it easier to match existing volumes to the new Pods that replace any that have failed.

Static Pod
A pod managed directly by the kubelet daemon on a specific node,
without the API server observing it.

Static Pods do not support ephemeral containers.

Taint
A core object consisting of three required properties: key, value, and effect. Taints prevent the scheduling of Pods on nodes or node groups.
Taints and tolerations work together to ensure that pods are not scheduled onto inappropriate nodes. One or more taints are applied to a node. A node should only schedule a Pod with the matching tolerations for the configured taints.

Toleration
A core object consisting of three required properties: key, value, and effect. Tolerations enable the scheduling of pods on nodes or node groups that have matching taints.
Tolerations and taints work together to ensure that pods are not scheduled onto inappropriate nodes. One or more tolerations are applied to a pod. A toleration indicates that the pod is allowed (but not required) to be scheduled on nodes or node groups with matching taints.

UID
A Kubernetes systems-generated string to uniquely identify objects.
Every object created over the whole lifetime of a Kubernetes cluster has a distinct UID. It is intended to distinguish between historical occurrences of similar entities.

Volume
A directory containing data, accessible to the containers in a Pod.
A Kubernetes volume lives as long as the Pod that encloses it. Consequently, a volume outlives any containers that run within the Pod, and data in the volume is preserved across container restarts.

See storage for more information.

Watch
A verb that is used to track changes to an object in Kubernetes as a stream. It is used for the efficient detection of changes.
A verb that is used to track changes to an object in Kubernetes as a stream. Watches allow efficient detection of changes; for example, a controller that needs to know whenever a ConfigMap has changed can use a watch rather than polling.

See Efficient Detection of Changes in API Concepts for more information.

Workload
A workload is an application running on Kubernetes.
Various core objects that represent different types or parts of a workload include the DaemonSet, Deployment, Job, ReplicaSet, and StatefulSet objects.

For example, a workload that has a web server and a database might run the database in one StatefulSet and the web server in a Deployment.